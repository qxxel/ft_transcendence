export interface Mesh {
  draw(ctx: CanvasRenderingContext2D): void;
  collide(other: Mesh): boolean;

  move(dx: number, dy: number): boolean;
  slope?(angle: number): boolean;
  getX(): number;
  getY(): number;
  getW(): number;
  getH(): number;
  getA(): number;
  // getR(): number;
}

export class	Rect2D implements Mesh {

  constructor(
    public	x: number,
    public	y: number,
    public	w: number,
    public	h: number,
  ) {}



  getCenter(): { x: number; y: number } {
    return {
      x: this.x + this.w / 2,
      y: this.y + this.h / 2
    };
  }

  draw(ctx : CanvasRenderingContext2D): void {
    ctx.fillRect(this.x, this.y, this.w, this.h);
  }

  collide(other: Mesh): boolean {
    if (other instanceof Rect2D) {
      return this.x < other.x + other.w &&
             this.x + this.w > other.x &&
             this.y < other.y + other.h &&
             this.y + this.h > other.y;
    }
    if (other instanceof Circ2D) {
      return other.collide(this);
    }
    return false;
  }

  move(dx: number, dy: number): boolean {
    this.x += dx;
    this.y += dy;
    return false;
  }

  getX(): number { return this.x; }
  getY(): number { return this.y; }
  getW(): number { return this.w; }
  getH(): number { return this.h; }
  getA(): number { return 0; }
}


export class	Circ2D {

  constructor(
    public	x: number,
    public	y: number,
    public	r: number,
  ) {}

  draw(ctx : CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fill();
  }

  collide(other: Mesh): boolean {
    if (other instanceof Circ2D) {
      const dx = this.x - other.x;
      const dy = this.y - other.y;
      return dx*dx + dy*dy <= (this.r + other.r)**2;
    }
    if (other instanceof Rect2D) {
      const closestX = Math.max(other.x, Math.min(this.x, other.x + other.w));
      const closestY = Math.max(other.y, Math.min(this.y, other.y + other.h));
      const dx = this.x - closestX;
      const dy = this.y - closestY;
      return dx*dx + dy*dy <= this.r*this.r;
    }
    return false;
  }

  move(dx: number, dy: number): boolean {
    this.x += dx;
    this.y += dy;
    return false;
  }

  getX(): number { return this.x; }
  getY(): number { return this.y; }
  getW(): number { return this.r; }
  getH(): number { return this.r; }
  getA(): number { return 0; }

}

export class	Line2D implements Mesh {

  constructor(
    public	x1: number,
    public	y1: number,
    public	x2: number,
    public	y2: number,
    public	w: number,
    public	h: number,
    public	angle: number,
  ) {}


  draw(ctx : CanvasRenderingContext2D): void {
    ctx.strokeStyle = '#e100ffaa';
    ctx.lineWidth = this.w; //ctx.lineWidth = stickWidth;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(this.x1, this.y1);
    ctx.lineTo(this.x2, this.y2);
    ctx.stroke();
  }

  collide(other: Mesh): boolean {
    // if (other instanceof Rect2D) {
    //   return this.x < other.x + other.w &&
    //          this.x + this.w > other.x &&
    //          this.y < other.y + other.h &&
    //          this.y + this.h > other.y;
    // }
    // if (other instanceof Circ2D) {
    //   return other.collide(this);
    // }
    return false;
  }

  getEnd(): { x: number; y: number } {
    return { x: this.x2, y: this.y2 };
  }

  move(dx: number, dy: number): boolean {
    this.x1 += dx;
    this.y1 += dy;
    this.x2 += dx;
    this.y2 += dy;
    return false;
  }

  slope(angle: number): boolean {
    this.angle += angle;
    this.x2 = this.x1 + Math.cos(this.angle) * this.h;
    this.y2 = this.y1 + Math.sin(this.angle) * this.h;
    return false;
  }

  getX(): number { return this.x2; }
  getY(): number { return this.y2; }
  getW(): number { return this.w; }
  getH(): number { return this.h; }
  getA(): number { return this.angle; }

}